	- 나머지 요소는 CPU에서 전달받은 데이터에 따라 주어진 고정적인 흐름에 따라 처리됨(Fixed)

### 버텍스(Vertex)

> **정점, 꼭지점, 모서리**
    
### 래스터화(Rasterization)

> **실세계에서는 무한한 연속체로 되어 있는 기하학적 요소(직선, 곡선, 면, ...)에 대한 데이터를 유한한 픽셀에 쪼개서 담는 처리를 말하며, 래스터화 과정을 거치면 프래그먼트가 생성된다.**

실세계의 수직선에서 0과 1을 잇는 선분을 생각해보자. 0과 1사이에는 0과 무한대 사이에 있는 것과 같은 개수의 무한한 점이 있다. 하지만 이 선분을 디스플레이 화면에 뿌릴 떄는 결국 디스플레이의 해상도에 따른 유한한 픽셀 갯수만큼의 데이터만 필요하다.

![](http://2.bp.blogspot.com/-GoQdMGtKbwg/Tb1EAWloDvI/AAAAAAAAACE/1Ss_HpvE9ng/s1600/Rasterization.png)

#### 양자화(Quantization)

> **실세계에서는 연속적인 무한한 데이터를 쳐내서 불연속적인 유한한 데이터로 만드는 것**

- 소리를 mp3로 만들 때 가청 주파수 정도의 데이터만 취한다.

- 움직이는 화면을 만들 때 가시 주파수 정도의 데이터만 취한다.

### 프래그먼트(Fragment)

> **래스터화의 결과로 나오는 픽셀 쪼가리(fragment) 단위의 정보**

넓은 의미에서는 픽셀이라고 봐도 크게 틀리지는 않으나, **컬러 버퍼에 저장된 픽셀을 수정하는데 필요한 데이터를 총칭**한다고 보는 것이 더 정확하다. 

### 그래픽 처리 전략

대부분의 그래픽 처리에서 공통적으로 사용되는 기본 전략은 **선 영역계산 - 후 색채우기**

#### 선 영역 계산 - Reflow - Vertex Shader

- 색을 칠할 영역 또는 공간 계산
- 기하 정보(Geometry)에 대한 연산이 필요하므로 CPU에 많은 부담
	- DOM 최적화의 주된 방법 중의 하나도 Reflow 최소화
- WebGL에서는 버텍스 셰이더가 Reflow 역할을 담당하며, CPU가 아닌 GPU에서 계산하므로 CPU 부담을 줄일 수 있고 결국 성능 향상으로 이어진다.

#### 후 색채우기 - Repaint - Fragment Shader

- 계산된 영역 또는 공간 내에 색 채우기
- 단순히 색을 채우는 것으로 Reflow에 비해 연산 부담이 덜하다.
- 화면 요소 자체에는 아무런 변화가 없더라도 마우스 이동 만으로도 Repaint가 발생
- 따라서 Repaint는 최소화 할 여지도 많지 않으며, Repaint 최소화를 통한 성능 향상 효과도 크지 않다.
- WebGL에서는 프래그먼트 셰이더가 Repaint 역할 담당

### 영역 계산 방식

#### 상대값 기준

- 어떤 기준 요소에 대한 상대적인 값으로 영역 계산
	- width=50%로 하면 어떤 디바이스에서도 폭 50%로 일관되게 표현 가능
- adaptive, reactive 하지만 계산 성능이 좀 낮음

#### 절대값 기준

- 절대적인 값으로 영역 계산
	- x=600 y=400로 하면 디바이스에 따라 화면에 보일 수도 안 보일 수도 있음
- 이론 상으로는 계산 성능이 좋지만, 실무적으로는 절대값 기준으로만 계산하는 경우는 거의 없고 상대값 기준 계산과 함께 사용되므로 계산 성능 상의 장점이 많이 희석된다.

### 용어 짝짓기

CPU 프로그래밍 | GPU 프로그래밍
:---:|:---:
프로그램|셰이더(Shader)
이미지|텍스쳐(Texture)
배열|버퍼(buffer)
